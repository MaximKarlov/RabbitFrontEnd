/**
 * Tuya Cloud-to-Cloud API Authentication Module
 *
 * This module generates authentication signatures for Tuya Cloud API requests.
 * It replaces Postman-specific functionality with Node.js equivalents.
 *
 * Key features:
 * - HMAC-SHA256 signature generation using Node.js crypto module
 * - Support for query parameters, headers, and request body
 * - Compatible with axios, fetch, and other HTTP clients
 *
 * @module tuya-auth
 */

import SHA256 from 'crypto-js/sha256';
import HmacSHA256 from 'crypto-js/hmac-sha256';
import Hex from 'crypto-js/enc-hex';

/**
 * Generate current timestamp in milliseconds
 * @returns {number} Current timestamp
 */
function getTime() {
  return new Date().getTime();
}

/**
 * Calculate HMAC-SHA256 signature for Tuya API authentication
 *
 * @param {string} clientId - Tuya client ID
 * @param {number} timestamp - Request timestamp in milliseconds
 * @param {string} nonce - Random nonce string (optional)
 * @param {string} signStr - String to sign (generated by stringToSign function)
 * @param {string} secret - Tuya client secret
 * @returns {string} Uppercase HMAC-SHA256 signature
 */
function calcSign(clientId, timestamp, nonce, signStr, secret) {
  // Concatenate: clientId + timestamp + nonce + signStr
  const str = clientId + timestamp + nonce + signStr;

  // Generate HMAC-SHA256 hash using Node.js crypto module
const hash = HmacSHA256(str, secret).toString(Hex);

  // Return uppercase signature
  return hash.toUpperCase();
}

/**
 * Calculate SHA256 hash of request body
 *
 * @param {string} bodyStr - Request body as string
 * @returns {string} SHA256 hash in hex format
 */
function calculateBodyHash(bodyStr) {
  const toHash = bodyStr || '';
return SHA256(toHash).toString(Hex);

}

/**
 * Convert query parameters or form data to sorted key-value pairs
 *
 * @param {Object} params - Parameters object
 * @returns {Object} Object containing sorted array of keys and key-value map
 */
function toJsonObj(params) {
  const arr = [];
  const map = {};

  if (!params) return { arr, map };

  // Handle different parameter formats
  if (Array.isArray(params)) {
    params.forEach(item => {
      if (!item.disabled && item.key) {
        arr.push(item.key);
        map[item.key] = item.value || '';
      }
    });
  } else if (typeof params === 'object') {
    Object.keys(params).forEach(key => {
      arr.push(key);
      map[key] = params[key] || '';
    });
  }

  return { arr, map };
}

/**
 * Replace path variables in URL (e.g., :deviceId -> actual value)
 *
 * @param {string} url - URL with path variables
 * @param {Object} pathVariables - Object containing path variable values
 * @returns {string} URL with replaced path variables
 */
function replacePathVariables(url, pathVariables = {}) {
  let result = url;

  // Replace :variable patterns with actual values
  Object.keys(pathVariables).forEach(key => {
    const pattern = new RegExp(`:${key}\\b`, 'g');
    result = result.replace(pattern, pathVariables[key] || '');
  });

  return result;
}

/**
 * Generate the signature string for Tuya API request
 *
 * This function creates the string that will be signed according to Tuya's
 * authentication specification: METHOD + "\n" + SHA256(body) + "\n" + headers + "\n" + URL
 *
 * @param {Object} options - Request options
 * @param {string} options.method - HTTP method (GET, POST, etc.)
 * @param {string} options.path - Request path (e.g., '/v1.0/token')
 * @param {Object} options.query - Query parameters object
 * @param {string|Object} options.body - Request body (string or object)
 * @param {string} options.contentType - Content type (json, form, urlencoded)
 * @param {Object} options.headers - Request headers
 * @param {Object} options.pathVariables - Path variables for URL replacement
 * @returns {Object} Object containing signUrl (string to sign) and url (final URL path)
 */
function stringToSign(options) {
  console.log("options",options)
  const {
    method = 'GET',
    path = '/',
    query = {},
    body = '',
    contentType = 'json',
    headers = {},
    pathVariables = {},
  } = options;

  let bodyStr = '';
  let url = '';
  let headersStr = '';
  const arr = [];
  const map = {};

  // Process query parameters
  if (query && Object.keys(query).length > 0) {
    const queryResult = toJsonObj(query);
    arr.push(...queryResult.arr);
    Object.assign(map, queryResult.map);
  }

  // Process request body based on content type
  if (body) {
    if (contentType === 'json') {
      // For JSON body, stringify if it's an object
      bodyStr = typeof body === 'string' ? body : JSON.stringify(body);
    } else if (contentType === 'form' || contentType === 'urlencoded') {
      // For form data, add to query parameters
      const bodyResult = toJsonObj(body);
      arr.push(...bodyResult.arr);
      Object.assign(map, bodyResult.map);
    }
  }

  // Calculate SHA256 hash of body
  const sha256 = calculateBodyHash(bodyStr);

  // Sort parameters and build query string
  const sortedArr = arr.sort();
  const queryParts = sortedArr.map(key => `${key}=${map[key]}`);

  // Build final URL path
  let finalPath = path.startsWith('/') ? path : `/${path}`;
  finalPath = replacePathVariables(finalPath, pathVariables);

  if (queryParts.length > 0) {
    url = `${finalPath}?${queryParts.join('&')}`;
  } else {
    url = finalPath;
  }

  // Process Signature-Headers if present
  if (headers['Signature-Headers']) {
    const signHeaderKeys = headers['Signature-Headers'].split(':');
    signHeaderKeys.forEach(key => {
      const val = headers[key] || '';
      headersStr += `${key}:${val}\n`;
    });
  }

  // Build the signature string: METHOD + "\n" + SHA256 + "\n" + headers + "\n" + URL
  const signUrl = `${method.toUpperCase()}\n${sha256}\n${headersStr}\n${url}`;
  
  return {
    signUrl,
    url,
  };
}

/**
 * Generate Tuya API authentication headers and URL
 *
 * This is the main function to generate all authentication components needed
 * for a Tuya Cloud API request.
 *
 * @param {Object} config - Configuration object
 * @param {string} config.clientId - Tuya client ID (required)
 * @param {string} config.secret - Tuya client secret (required)
 * @param {string} config.method - HTTP method (default: 'GET')
 * @param {string} config.path - Request path (default: '/')
 * @param {Object} config.query - Query parameters
 * @param {string|Object} config.body - Request body
 * @param {string} config.contentType - Content type: 'json', 'form', 'urlencoded' (default: 'json')
 * @param {Object} config.headers - Additional headers
 * @param {string} config.accessToken - Access token (optional, for authenticated requests)
 * @param {string} config.nonce - Custom nonce (optional, will be generated if not provided)
 * @param {number} config.timestamp - Custom timestamp (optional, will be generated if not provided)
 * @param {Object} config.pathVariables - Path variables for URL replacement
 * @returns {Object} Object containing headers, url, timestamp, and sign
 */
function generateAuth(config) {
  const {
    clientId,
    secret,
    method = 'GET',
    path = '/',
    query = {},
    body = '',
    contentType = 'json',
    headers = {},
    accessToken = '',
    nonce = '',
    timestamp = getTime(),
    pathVariables = {},
  } = config;

  // Validate required parameters
  if (!clientId || !secret) {
    throw new Error('clientId and secret are required');
  }

  // Generate signature string
  const signResult = stringToSign({
    method,
    path,
    query,
    body,
    contentType,
    headers,
    pathVariables,
  });


  function calcSignAccess(
    clientId,
    accessToken,
    timestamp,
    nonce,
    signStr,
    secret
  ) {
    // Concatenate: clientId + timestamp + nonce + signStr
    const str = clientId + accessToken + timestamp + nonce + signStr;

    // Generate HMAC-SHA256 hash using Node.js crypto module
    const hash = HmacSHA256(str, secret).toString(Hex);

    // Return uppercase signature
    return hash.toUpperCase();
  }

  // Calculate signature
  const sign = calcSignAccess(
    clientId,
    accessToken,
    timestamp,
    nonce,
    signResult.signUrl,
    secret
  );

  // Build authentication headers
  const authHeaders = {
    client_id: clientId,
    sign: sign,
    t: timestamp.toString(),
    sign_method: 'HMAC-SHA256',
  };

  // Add nonce if provided
  if (nonce) {
    authHeaders['nonce'] = nonce;
  }

  // Add access token if provided (for authenticated requests)
  if (accessToken) {
    authHeaders['access_token'] = accessToken;
  }

  // Merge with additional headers
  const finalHeaders = { ...authHeaders, ...headers };

  return {
    headers: finalHeaders,
    url: signResult.url,
    timestamp,
    sign,
  };
}

/**
 * Generate authentication for token request (simple mode)
 *
 * Convenience function for getting access token with grant_type=1
 *
 * @param {Object} config - Configuration object
 * @param {string} config.clientId - Tuya client ID
 * @param {string} config.secret - Tuya client secret
 * @param {string} config.baseUrl - Base URL (e.g., 'https://openapi.tuyaus.com')
 * @returns {Object} Object containing full URL and headers for token request
 */
function generateTokenAuth({ clientId, secret, baseUrl }) {

  const auth = generateAuth({
    clientId,
    secret,
    method: 'GET',
    path: '/v1.0/token',
    query: { grant_type: '1' },
  });

  console.log("auth",auth)

  return {
    url: `${baseUrl}${auth.url}`,
    headers: auth.headers,
  };
}

// Export functions
export { generateAuth, generateTokenAuth, calcSign, stringToSign, getTime };
